Delegate a workspace to a remote Executor for task execution.

Delegation enables **parallel execution** — while the Executor works on one task, you can continue with other work or launch more delegations. This dramatically improves throughput compared to doing everything sequentially.

## Why delegate

- **Parallelism**: Run multiple tasks simultaneously instead of one-by-one
- **Depth**: Executor can focus deeply on one task while you handle others
- **Specialization**: Remote agents may have different tools, environments, or expertise
- **Efficiency**: Offload substantial work and stay productive

Consider delegating any task that would take significant time — tests, refactoring, code review, implementation of independent features, documentation, etc.

## When NOT to delegate

- Task requires real-time back-and-forth with the user

## Background mode

**Always prefer background=true.** This returns immediately with a delegation_id, letting you:
- Launch multiple delegations in parallel
- Continue with other work while waiting
- Retrieve results later with `delegate_output`

Use background=false **only** when you have nothing else to do and must wait for this result.

## Snapshot modes

- **auto** (default): Executor's changes are automatically applied to your workspace
- **staged**: Changes are saved but require manual review and apply via `delegate_snapshots` and `delegate_apply_snapshot`
- **discard**: Changes are not saved (useful for read-only analysis tasks)

Use `staged` when you want to review the executor's work before accepting it.

## Multi-resource support

You can delegate multiple directories with different access modes:

```
delegate(
  resources: [
    { name: "src", path: "/project/src", mode: "rw" },
    { name: "data", path: "/project/data", mode: "ro" },
  ],
  ...
)
```

Or use the simpler `workspace_dir` for single-directory delegations.

## Authentication

If the executor requires authentication, provide:
- `auth_type`: "api_key", "bearer", or "oauth2"
- `auth_credential`: The actual token or key

## Typical workflow

1. Launch delegation with `background: true`
2. Continue with other independent work (local tasks, more delegations, etc.)
3. When ready for results, call `delegate_output(delegation_id, block: true, timeout: ...)`
4. If using `snapshot_mode: "staged"`, review with `delegate_snapshots` then apply or discard

This pattern maximizes parallelism and avoids idle waiting.

## Writing effective prompts

Structure your prompt with:
- **What to do**: Clear, specific goal
- **Expected outcome**: What success looks like
- **Context**: Relevant file paths, patterns, constraints
- **What NOT to do**: Scope boundaries to prevent over-engineering

{executors}

## Examples

### Launch and continue working
```
delegate(background: true, description: "Add unit tests", ...) → delegation_id: "dlg_abc"
# ... do other work locally ...
delegate_output(delegation_id: "dlg_abc", block: true, timeout: 300)
```

### Parallel delegations
```
delegate(background: true, description: "Fix linting errors", ...) → "dlg_1"
delegate(background: true, description: "Add unit tests", ...) → "dlg_2"
# ... do other work ...
delegate_output(delegation_id: "dlg_1", block: true)
delegate_output(delegation_id: "dlg_2", block: true)
```

### Staged snapshot workflow
```
delegate(background: true, snapshot_mode: "staged", description: "Refactor auth", ...) → "dlg_abc"
# ... wait for completion ...
delegate_snapshots(delegation_id: "dlg_abc")
# Review the snapshots, then:
delegate_apply_snapshot(delegation_id: "dlg_abc", snapshot_id: "snap_1")
```

### Synchronous (only when nothing else to do)
```
delegate(background: false, description: "Generate config", ...)
```
